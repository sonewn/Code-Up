"""
피보나치수 나머지 구하기 v2
: 나머지 연산 성질을 반영하여 오버플로우 방지

[관련 참조 자료: https://school.programmers.co.kr/learn/courses/14743/lessons/116435]
n이 매우 큰 경우 n번째 피보나치 수는 언어가 표현할 수 있는 자료형의 범위를 넘어가, 오버플로우가 납니다.

ex)
47번째 피보나치 수는 2,971,215,073이고, 이 수는 32비트 정수(ex. int) 범위를 넘어 오버플로우가 발생합니다.
100,000번째 피보나치 수는 자릿수가 20,000을 넘어가며, 이는 64비트 정수(ex. long) 범위를 넘어 오버플로우가 발생합니다.

따라서 아래와 같은 나머지 연산 특징을 반영하여 코드를 수정하였습니다.
> (a + b) % m = ((a % m) + (b % m)) % m

"""

def solution(n):
    """
    p : n번째 피보나치 수
    p1 : n-2번째 피보나치 수
    p2 : n-1번째 피보나치 수
    """
    p1=0
    p2=1
    for idx in range(1,n): #1~n-1
        if idx==n-1:
            answer = (p1%1234567+p2%1234567)%1234567
        else:
            p = p1+p2
            p1 = p2
            p2 = p

    return answer

print(solution(100000))